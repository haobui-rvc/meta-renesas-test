From 8094b092ba26d605e69e1d9271149617acfe01f8 Mon Sep 17 00:00:00 2001
From: Hien Huynh <hien.huynh.px@rvc.renesas.com>
Date: Wed, 14 Nov 2018 15:32:34 +0700
Subject: [PATCH 511/628] mmc: sh_mobile_sdhi: Add UHS-I mode support

The function supports SDR50 and SDR104 modes.
In addition, SCC sampling clock also supports.

Signed-off-by: Hien Huynh <hien.huynh.px@rvc.renesas.com>
The function supports SDR50 and SDR104 modes.
Signed-off-by: vietn <vietn@fsoft.com.vn>
---
 drivers/mmc/host/sh_mobile_sdhi.c | 445 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 433 insertions(+), 12 deletions(-)

diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
index 5ceac5f..1fba4d7 100644
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@ -30,19 +30,31 @@
 #include <linux/mfd/tmio.h>
 #include <linux/sh_dma.h>
 #include <linux/delay.h>
+#include <linux/regulator/consumer.h>
 
 #include "tmio_mmc.h"
 
-#define EXT_ACC           0xe4
+#define HOST_MODE           0xe4
 
 #define host_to_priv(host) container_of((host)->pdata, struct sh_mobile_sdhi, mmc_data)
 
+struct sh_mobile_sdhi_scc {
+	unsigned long clk;	/* clock for SDR104 */
+	u32 tap;		/* sampling clock position for SDR104 */
+};
+
 struct sh_mobile_sdhi_of_data {
 	unsigned long tmio_flags;
 	unsigned long capabilities;
 	unsigned long capabilities2;
 	enum dma_slave_buswidth dma_buswidth;
 	dma_addr_t dma_rx_offset;
+	unsigned int max_blk_count;
+	unsigned short max_segs;
+	bool sdbuf_64bit;
+	int scc_offset;
+	struct sh_mobile_sdhi_scc *taps;
+	int taps_num;
 };
 
 static const struct sh_mobile_sdhi_of_data sh_mobile_sdhi_of_cfg[] = {
@@ -57,12 +69,27 @@ static const struct sh_mobile_sdhi_of_data of_rcar_gen1_compatible = {
 	.capabilities	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
 };
 
+/* Definitions for sampling clocks */
+static struct sh_mobile_sdhi_scc rcar_gen2_scc_taps[] = {
+	{
+		.clk = 156000000,
+		.tap = 0x00000703,
+	},
+	{
+		.clk = 0,
+		.tap = 0x00000300,
+	},
+};
+
 static const struct sh_mobile_sdhi_of_data of_rcar_gen2_compatible = {
 	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_WRPROTECT_DISABLE |
 			  TMIO_MMC_CLK_ACTUAL,
 	.capabilities	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
 	.dma_buswidth	= DMA_SLAVE_BUSWIDTH_4_BYTES,
 	.dma_rx_offset	= 0x2000,
+	.scc_offset = 0x0300,
+	.taps = rcar_gen2_scc_taps,
+	.taps_num = ARRAY_SIZE(rcar_gen2_scc_taps),
 };
 
 static const struct of_device_id sh_mobile_sdhi_of_match[] = {
@@ -91,6 +118,8 @@ struct sh_mobile_sdhi {
 	struct clk *clk;
 	struct tmio_mmc_data mmc_data;
 	struct tmio_mmc_dma dma_priv;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default, *pins_uhs;
 };
 
 static void sh_mobile_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
@@ -114,7 +143,7 @@ static void sh_mobile_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 			val = 0x0000;
 		else if (width == 32)
 			val = 0x0101;
-		else    /* width = 16 */
+		else	/* width = 16 */
 			val = 0x0001;
 		break;
 	default:
@@ -122,7 +151,7 @@ static void sh_mobile_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 		return;
 	}
 
-	sd_ctrl_write16(host, EXT_ACC, val);
+	sd_ctrl_write16(host, HOST_MODE, val);
 }
 
 static int sh_mobile_sdhi_clk_enable(struct platform_device *pdev, unsigned int *f)
@@ -150,6 +179,316 @@ static void sh_mobile_sdhi_clk_disable(struct platform_device *pdev)
 	clk_disable_unprepare(priv->clk);
 }
 
+static void sh_mobile_sdhi_set_clk_div(struct platform_device *pdev,
+				       int state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct tmio_mmc_host *host = mmc_priv(mmc);
+
+	if (state) {
+		sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 &
+				sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+		sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x00ff);
+	}
+}
+
+#define SH_MOBILE_SDHI_DAT0	0x0080
+static int sh_mobile_sdhi_card_busy(struct tmio_mmc_host *host)
+{
+	u16 dat0;
+
+	/* check to see DAT[3:0] */
+	dat0 = sd_ctrl_read16(host, CTL_STATUS2);
+	return !(dat0 & SH_MOBILE_SDHI_DAT0);
+}
+
+#define SH_MOBILE_SDHI_SIGNAL_180V	0
+#define SH_MOBILE_SDHI_SIGNAL_330V	1
+
+static int sh_mobile_sdhi_set_ioctrl(struct tmio_mmc_host *host, int state)
+{
+	struct platform_device *pdev = host->pdev;
+	struct sh_mobile_sdhi *priv =
+		container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);
+	struct pinctrl_state *pstate;
+	int ret;
+
+	if (state == SH_MOBILE_SDHI_SIGNAL_330V) {
+		pstate = priv->pins_default;
+	} else if (state == SH_MOBILE_SDHI_SIGNAL_180V) {
+		pstate = priv->pins_uhs;
+	} else {
+		dev_err(&pdev->dev, "update_ioctrl: unknown state\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (!pstate) {
+		ret = -EIO;
+		goto err;
+	}
+
+	ret = pinctrl_select_state(priv->pinctrl, pstate);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int sh_mobile_sdhi_start_signal_voltage_switch(
+	struct tmio_mmc_host *host, unsigned char signal_voltage)
+{
+	struct mmc_host *mmc = host->mmc;
+	int ret;
+
+	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		/* Enable 3.3V Signal */
+		if (!IS_ERR(mmc->supply.vqmmc)) {
+			/* ioctrl */
+			ret = sh_mobile_sdhi_set_ioctrl(host,
+						SH_MOBILE_SDHI_SIGNAL_330V);
+			if (ret) {
+				dev_err(&host->pdev->dev,
+					"3.3V pin function control failed\n");
+				return -EIO;
+			}
+
+			ret = regulator_set_voltage(mmc->supply.vqmmc,
+						    3300000, 3300000);
+			if (ret) {
+				dev_warn(&host->pdev->dev,
+					 "3.3V signalling voltage failed\n");
+				return -EIO;
+			}
+		} else {
+			return -EIO;
+		}
+		usleep_range(5000, 10000);
+	} else if (signal_voltage == MMC_SIGNAL_VOLTAGE_180) {
+		/* Enable 1.8V Signal */
+		if (!IS_ERR(mmc->supply.vqmmc)) {
+			ret = regulator_set_voltage(mmc->supply.vqmmc,
+						    1800000, 1800000);
+			if (ret) {
+				dev_warn(&host->pdev->dev,
+					 "1.8V signalling voltage failed\n");
+				return -EIO;
+			}
+			/* ioctrl */
+			ret = sh_mobile_sdhi_set_ioctrl(host,
+						SH_MOBILE_SDHI_SIGNAL_180V);
+			if (ret) {
+				dev_err(&host->pdev->dev,
+					"1.8V pin function control failed\n");
+				return -EIO;
+			}
+		} else {
+			return -EIO;
+		}
+		/* Wait for 5ms */
+		usleep_range(5000, 10000);
+	} else {
+		/* No signal voltage switch required */
+	}
+
+	return 0;
+}
+
+/* SCC registers */
+#define SH_MOBILE_SDHI_SCC_DTCNTL	0x000
+#define SH_MOBILE_SDHI_SCC_TAPSET	0x002
+#define SH_MOBILE_SDHI_SCC_DT2FF	0x004
+#define SH_MOBILE_SDHI_SCC_CKSEL	0x006
+#define SH_MOBILE_SDHI_SCC_RVSCNTL	0x008
+#define SH_MOBILE_SDHI_SCC_RVSREQ	0x00A
+
+/* Definitions for values the SH_MOBILE_SDHI_SCC_DTCNTL register */
+#define SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN		(1 << 0)
+/* Definitions for values the SH_MOBILE_SDHI_SCC_CKSEL register */
+#define SH_MOBILE_SDHI_SCC_CKSEL_DTSEL		(1 << 0)
+/* Definitions for values the SH_MOBILE_SDHI_SCC_RVSCNTL register */
+#define SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN	(1 << 0)
+/* Definitions for values the SH_MOBILE_SDHI_SCC_RVSREQ register */
+#define SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR	(1 << 2)
+
+static inline u32 sd_scc_read32(struct tmio_mmc_host *host, int addr)
+{
+	struct platform_device *pdev = host->pdev;
+	const struct of_device_id *of_id =
+		of_match_device(sh_mobile_sdhi_of_match, &pdev->dev);
+	const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
+
+	return readl(host->ctl + of_data->scc_offset +
+		     (addr << host->bus_shift));
+}
+
+static inline void sd_scc_write32(struct tmio_mmc_host *host, int addr,
+				  u32 val)
+{
+	struct platform_device *pdev = host->pdev;
+	const struct of_device_id *of_id =
+		of_match_device(sh_mobile_sdhi_of_match, &pdev->dev);
+	const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
+
+	writel(val, host->ctl + of_data->scc_offset +
+	       (addr << host->bus_shift));
+}
+
+static bool sh_mobile_sdhi_inquiry_tuning(struct tmio_mmc_host *host)
+{
+	/* SDHI should be tuning only SDR104 and HS200 */
+	if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104 ||
+	    host->mmc->ios.timing == MMC_TIMING_MMC_HS200)
+		return true;
+
+	return false;
+}
+
+static void sh_mobile_sdhi_init_tuning(struct tmio_mmc_host *host,
+							unsigned long *num)
+{
+	/* set sampling clock selection range */
+	if (host->scc_tapnum)
+		sd_scc_write32(host, SH_MOBILE_SDHI_SCC_DTCNTL,
+				host->scc_tapnum << 16);
+
+	/* Initialize SCC */
+	sd_ctrl_write32(host, CTL_STATUS, 0x00000000);
+
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_DTCNTL,
+		SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN |
+		sd_scc_read32(host, SH_MOBILE_SDHI_SCC_DTCNTL));
+
+	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 &
+		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_CKSEL,
+		SH_MOBILE_SDHI_SCC_CKSEL_DTSEL |
+		sd_scc_read32(host, SH_MOBILE_SDHI_SCC_CKSEL));
+
+	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 |
+		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSCNTL,
+		~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &
+		sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSCNTL));
+
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_DT2FF, host->scc_tappos);
+
+	/* Read TAPNUM */
+	*num = (sd_scc_read32(host, SH_MOBILE_SDHI_SCC_DTCNTL) >> 16) & 0xff;
+}
+
+static int sh_mobile_sdhi_prepare_tuning(struct tmio_mmc_host *host,
+							unsigned long tap)
+{
+	/* Set sampling clock position */
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_TAPSET, tap);
+
+	return 0;
+}
+
+#define SH_MOBILE_SDHI_MAX_TAP	3
+static int sh_mobile_sdhi_select_tuning(struct tmio_mmc_host *host,
+							unsigned long *tap)
+{
+	unsigned long tap_num;	/* total number of taps */
+	unsigned long tap_cnt;	/* counter of tuning success */
+	unsigned long tap_set;	/* tap position */
+	unsigned long tap_start;	/* start position of tuning success */
+	unsigned long tap_end;	/* end position of tuning success */
+	unsigned long ntap;	/* temporary counter of tuning success */
+	unsigned long i;
+
+	/* Clear SCC_RVSREQ */
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSREQ, 0);
+
+	/* Select SCC */
+	tap_num = (sd_scc_read32(host,
+				 SH_MOBILE_SDHI_SCC_DTCNTL) >> 16) & 0xff;
+
+	tap_cnt = 0;
+	ntap = 0;
+	tap_start = 0;
+	tap_end = 0;
+	for (i = 0; i < tap_num * 2; i++) {
+		if (tap[i] == 0)
+			ntap++;
+		else {
+			if (ntap > tap_cnt) {
+				tap_start = i - ntap;
+				tap_end = i - 1;
+				tap_cnt = ntap;
+			}
+			ntap = 0;
+		}
+	}
+
+	if (ntap > tap_cnt) {
+		tap_start = i - ntap;
+		tap_end = i - 1;
+		tap_cnt = ntap;
+	}
+
+	if (tap_cnt >= SH_MOBILE_SDHI_MAX_TAP)
+		tap_set = (tap_start + tap_end) / 2 % tap_num;
+	else
+		return -EIO;
+
+	/* Set SCC */
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_TAPSET, tap_set);
+
+	/* Enable auto re-tuning */
+	sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSCNTL,
+		SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN |
+		sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSCNTL));
+
+	return 0;
+}
+
+static bool sh_mobile_sdhi_retuning(struct tmio_mmc_host *host)
+{
+	/* Check SCC error */
+	if (sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSCNTL) &
+	    SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &&
+	    sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSREQ) &
+	    SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR) {
+		/* Clear SCC error */
+		sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSREQ, 0);
+		return true;
+	}
+	return false;
+}
+
+static void sh_mobile_sdhi_hw_reset(struct tmio_mmc_host *host)
+{
+	struct tmio_mmc_data *pdata = host->pdata;
+
+	if (pdata->flags & TMIO_MMC_HAS_UHS_SCC) {
+		/* Reset SCC */
+		sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 &
+			sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+
+		sd_scc_write32(host, SH_MOBILE_SDHI_SCC_CKSEL,
+			~SH_MOBILE_SDHI_SCC_CKSEL_DTSEL &
+			sd_scc_read32(host, SH_MOBILE_SDHI_SCC_CKSEL));
+
+		sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 |
+			sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+
+		sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSCNTL,
+			~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &
+			sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSCNTL));
+
+		sd_scc_write32(host, SH_MOBILE_SDHI_SCC_RVSCNTL,
+			~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &
+			sd_scc_read32(host, SH_MOBILE_SDHI_SCC_RVSCNTL));
+	}
+}
+
 static int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)
 {
 	int timeout = 1000;
@@ -177,6 +516,7 @@ static int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)
 	case CTL_SD_MEM_CARD_OPT:
 	case CTL_TRANSACTION_CTL:
 	case CTL_DMA_ENABLE:
+	case HOST_MODE:
 		return sh_mobile_sdhi_wait_idle(host);
 	}
 
@@ -203,10 +543,12 @@ static int sh_mobile_sdhi_multi_io_quirk(struct mmc_card *card,
 
 static void sh_mobile_sdhi_enable_dma(struct tmio_mmc_host *host, bool enable)
 {
+	int dma_width = host->dma->sdbuf_64bit ? 64 : 32;
+
 	sd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? 2 : 0);
 
 	/* enable 32bit access if DMA mode if possibile */
-	sh_mobile_sdhi_sdbuf_width(host, enable ? 32 : 16);
+	sh_mobile_sdhi_sdbuf_width(host, enable ? dma_width : 16);
 }
 
 static int sh_mobile_sdhi_probe(struct platform_device *pdev)
@@ -216,13 +558,14 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 	struct sh_mobile_sdhi *priv;
 	struct tmio_mmc_data *mmc_data;
 	struct tmio_mmc_data *mmd = pdev->dev.platform_data;
-	const struct device_node *np = pdev->dev.of_node;
 	struct tmio_mmc_host *host;
 	struct resource *res;
-	int irq, ret, i = 0;
+	struct device_node *np = pdev->dev.of_node;
+	int irq, ret, i;
 	bool multiplexed_isr = true;
 	struct tmio_mmc_dma *dma_priv;
-	int clk_rate = 0;
+	int clk_rate;
+	u32 num, tapnum = 0, tappos;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
@@ -256,6 +599,46 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 			}
 	}
 
+	if (np && !of_property_read_u32(np, "renesas,mmc-scc-tapnum", &num))
+		tapnum = num;
+
+	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (!IS_ERR(priv->pinctrl)) {
+		const char *p;
+		struct pinctrl_state *pstate;
+
+		num = of_property_count_strings(np, "pinctrl-names");
+		if (num < 1) {
+			dev_err(&pdev->dev,
+				"not find pinctrl for voltage switch\n");
+			ret =  -ENODEV;
+			goto eprobe;
+		}
+
+		for (i = 0; i < num; i++) {
+			ret = of_property_read_string_index(np, "pinctrl-names",
+							    i, &p);
+			if (ret)
+				continue;
+
+			pstate = pinctrl_lookup_state(priv->pinctrl, p);
+			if (IS_ERR(pstate))
+				continue;
+
+			if (!strcmp(p, "default"))
+				priv->pins_default = pstate;
+			else if (!strcmp(p, "uhs"))
+				priv->pins_uhs = pstate;
+		}
+
+		if (!priv->pins_default && !priv->pins_uhs) {
+			dev_err(&pdev->dev,
+				"not find pinctrl state for voltage switch\n");
+			ret =  -ENODEV;
+			goto eprobe;
+		}
+	}
+
 	host = tmio_mmc_host_alloc(pdev);
 	if (!host) {
 		ret = -ENOMEM;
@@ -266,13 +649,22 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 	host->write16_hook	= sh_mobile_sdhi_write16_hook;
 	host->clk_enable	= sh_mobile_sdhi_clk_enable;
 	host->clk_disable	= sh_mobile_sdhi_clk_disable;
+	host->card_busy		= sh_mobile_sdhi_card_busy;
 	host->multi_io_quirk	= sh_mobile_sdhi_multi_io_quirk;
-
+	host->set_clk_div	= sh_mobile_sdhi_set_clk_div;
+	host->start_signal_voltage_switch =
+			sh_mobile_sdhi_start_signal_voltage_switch;
+	host->inquiry_tuning = sh_mobile_sdhi_inquiry_tuning;
+	host->init_tuning = sh_mobile_sdhi_init_tuning;
+	host->prepare_tuning = sh_mobile_sdhi_prepare_tuning;
+	host->select_tuning = sh_mobile_sdhi_select_tuning;
+	host->retuning = sh_mobile_sdhi_retuning;
+	host->hw_reset = sh_mobile_sdhi_hw_reset;
+	host->scc_tapnum = tapnum;
 	/* SD control register space size */
 	if (resource_size(res) > 0x400) /* 0x400 for bus_shift=2 */
 		host->bus_shift = 2;
-	/* SD control register space size is 0x100, 0x200 for bus_shift=1 */
-	else if (resource_size(res) > 0x100)
+	else if (resource_size(res) > 0x100) /* 0x100, 0x200 for bus_shift=1 */
 		host->bus_shift = 1;
 	else
 		host->bus_shift = 0;
@@ -309,11 +701,39 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 
 	if (of_id && of_id->data) {
 		const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
+		const struct sh_mobile_sdhi_scc *taps = of_data->taps;
 		mmc_data->flags |= of_data->tmio_flags;
 		mmc_data->capabilities |= of_data->capabilities;
 		mmc_data->capabilities2 |= of_data->capabilities2;
 		mmc_data->dma_rx_offset = of_data->dma_rx_offset;
+		mmc_data->max_blk_count	= of_data->max_blk_count;
+		mmc_data->max_segs = of_data->max_segs;
 		dma_priv->dma_buswidth = of_data->dma_buswidth;
+		dma_priv->sdbuf_64bit = of_data->sdbuf_64bit;
+		if (np && !of_property_read_u32(np, "renesas,mmc-scc-tappos",
+						&tappos)) {
+			host->scc_tappos = tappos;
+		} else {
+			for (i = 0, taps = of_data->taps;
+			     i < of_data->taps_num; i++, taps++) {
+				if (taps->clk == 0 || taps->clk == clk_rate) {
+					host->scc_tappos = taps->tap;
+					break;
+				}
+			}
+			if (taps->clk != 0 && taps->clk != clk_rate)
+				dev_warn(&host->pdev->dev, "Unknown clock rate for SDR104 and HS200\n");
+		}
+	}
+
+	if (of_find_property(np, "sd-uhs-sdr50", NULL))
+		mmc_data->capabilities |= MMC_CAP_UHS_SDR50;
+	if (of_find_property(np, "sd-uhs-sdr104", NULL))
+		mmc_data->capabilities |= MMC_CAP_UHS_SDR104;
+
+	if (mmc_data->capabilities & MMC_CAP_UHS_SDR104) {
+		mmc_data->capabilities |= MMC_CAP_HW_RESET;
+		mmc_data->flags |= TMIO_MMC_HAS_UHS_SCC;
 	}
 
 	ret = tmio_mmc_host_probe(host, mmc_data);
@@ -358,6 +778,7 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 	}
 
 	if (multiplexed_isr) {
+		i = 0;
 		while (1) {
 			irq = platform_get_irq(pdev, i);
 			if (irq < 0)
@@ -402,8 +823,8 @@ static int sh_mobile_sdhi_remove(struct platform_device *pdev)
 }
 
 static const struct dev_pm_ops tmio_mmc_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-			pm_runtime_force_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(tmio_mmc_host_suspend,
+			tmio_mmc_host_resume)
 	SET_RUNTIME_PM_OPS(tmio_mmc_host_runtime_suspend,
 			tmio_mmc_host_runtime_resume,
 			NULL)
-- 
2.7.4

