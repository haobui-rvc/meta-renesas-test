From d1c4e84d965ec36c9068fefdb17f5cda021ccab2 Mon Sep 17 00:00:00 2001
From: "Nguyen Van Linh [FGA.BU13]" <LinhNV25@fsoft.com.vn>
Date: Wed, 14 Nov 2018 14:50:46 +0700
Subject: [PATCH 290/628] media: rcar-dvdec: add rcar-dvdec driver

This is a workaround solution to use i2c to bind vin and dvdec.

Signed-off-by: nhannguyen <nhan.nguyen.yb@renesas.com>
Signed-off-by: Nguyen Van Linh [FGA.BU13] <LinhNV25@fsoft.com.vn>
Signed-off-by: vietn <vietn@fsoft.com.vn>
---
 drivers/media/platform/Makefile     |    1 +
 drivers/media/platform/rcar-dvdec.c | 1146 +++++++++++++++++++++++++++++++++++
 drivers/media/platform/rcar-dvdec.h |  403 ++++++++++++
 3 files changed, 1550 insertions(+)
 create mode 100644 drivers/media/platform/rcar-dvdec.c
 create mode 100644 drivers/media/platform/rcar-dvdec.h

diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index efa0295..2ff47ad 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -53,5 +53,6 @@ obj-y	+= omap/
 obj-$(CONFIG_VIDEO_AM437X_VPFE)		+= am437x/
 
 obj-$(CONFIG_VIDEO_XILINX)		+= xilinx/
+obj-$(CONFIG_VIDEO_RCAR_VIN) 		+= rcar-dvdec.o
 
 ccflags-y += -I$(srctree)/drivers/media/i2c
diff --git a/drivers/media/platform/rcar-dvdec.c b/drivers/media/platform/rcar-dvdec.c
new file mode 100644
index 0000000..76834d7
--- /dev/null
+++ b/drivers/media/platform/rcar-dvdec.c
@@ -0,0 +1,1146 @@
+/*
+ * rcar_dvdec
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation
+ *
+ * rcar-dvdec.c R-Car E2X Digital video decoder driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <linux/clk.h>
+
+#include "rcar-dvdec.h"
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+const struct reg_color rcar_dvdec_reg_color[8] = {
+
+	/* TGCR1,  TGCR2,   TGCR3,   HAFCCR1, HAFCCR2, HAFCCR3, */
+	/* VCDWCR1,BTLCR,   ACCCR1,  AGCCR1,  YCSCR3,  YCSCR4,  */
+	/* YCSCR5,  YCSCR6,  YCSCR7,  YCSCR9,  YCSCR12          */
+
+	/* 0 : DVDEC_NTSC358 */
+	{ 0x0100,  0x40F1,  0x0594,  0xC2B4,  0x0B18,  0x8A50,
+	  0x53CF,  0x741F,  0x50DC,  0x08E6,  0x2204,  0x3408,
+	  0x2006,  0x0806,  0x6325,  0x8660,  0x0205,  },
+
+	/* 1 : DVDEC_NTSC443 */
+	{ 0x0100,  0x4D20,  0x0584,  0xC2C0,  0x0B11,  0x8A76,
+	  0x2BCF,  0x742F,  0x50DC,  0x08E6,  0x2204,  0x3408,
+	  0x2006,  0x0806,  0x6325,  0x8660,  0x0205,  },
+
+	/* 2 : DVDEC_PAL443 */
+	{ 0x0100,  0x4D20,  0x0584,  0xC2C0,  0x0B11,  0x8A76,
+	  0x2BCF,  0x747D,  0x50DC,  0x08F2,  0x2203,  0x4FC2,
+	  0x200A,  0x0F0A,  0x3328,  0x0000,  0x0001,  },
+
+	/* 3 : DVDEC_PALM */
+	{ 0x0100,  0x40F1,  0x0594,  0xC2B4,  0x0B18,  0x8A50,
+	  0x53CF,  0x7477,  0x50E6,  0x08F2,  0x2203,  0x4FC2,
+	  0x200A,  0x0F0A,  0x3328,  0x0000,  0x0001,  },
+
+	/* 4 : DVDEC_PALN */
+	{ 0x0100,  0x4D20,  0x0584,  0xC2C0,  0x0B11,  0x8A76,
+	  0x2BCF,  0x747B,  0x50E6,  0x08F2,  0x2203,  0x4FC2,
+	  0x200A,  0x0F0A,  0x3328,  0x0000,  0x0001,  },
+
+	/* 5 : DVDEC_SECAM */
+	{ 0x0100,  0x4D20,  0x0584,  0xC2C0,  0x0B11,  0x8A76,
+	  0x2BCF,  0x74BE,  0x50DC,  0x08F2,  0x2204,  0x3401,
+	  0x2006,  0x0F06,  0x3328,  0x8660,  0x0005,  },
+
+	/* 6 : NTSC-443 60 */
+	{ 0x0100,  0x40F1,  0x0594,  0xC2B4,  0x0B18,  0x8A50,
+	  0x53CF,  0x742F,  0x50DC,  0x08E6,  0x2204,  0x3408,
+	  0x2006,  0x0806,  0x6325,  0x8660,  0x0205,  },
+
+	/* 7 : PAL 60 */
+	{ 0x0100,  0x40F1,  0x0594,  0xC2B4,  0x0B18,  0x8A50,
+	  0x53CF,  0x747D,  0x50E6,  0x08F2,  0x2203,  0x4FC2,
+	  0x200A,  0x0F0A,  0x3238,  0x0000,  0x0001,  },
+};
+
+const struct dvdec_rect rcar_dvdec_rect[8] = {
+	{ 16, 241, 0, 1428},	/* 0 : DVDEC_NTSC358 */
+	{ 16, 241, 0, 1428},	/* 1 : DVDEC_NTSC443 */
+	{ 19, 288, 0, 1412},	/* 2 : DVDEC_PAL443 */
+	{ 16, 241, 0, 1428},	/* 3 : DVDEC_PALM */
+	{ 19, 288, 0, 1412},	/* 4 : DVDEC_PALN */
+	{ 19, 288, 0, 1412},	/* 5 : DVDEC_SECAM */
+	{ 16, 241, 0, 1428},	/* 6 : NTSC-443 60 */
+	{ 16, 241, 0, 1428},	/* 7 : PAL 60 */
+};
+
+struct rcar_dvdec_color_format {
+	u32 code;
+	u32 colorspace;
+};
+
+/*
+ * supported color format list
+ */
+static const struct rcar_dvdec_color_format rcar_dvdec_cfmts[] = {
+	{
+		.code		= MEDIA_BUS_FMT_YUYV10_1X20, /*MEDIA_BUS_FMT_YUYV10_1X20, */
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
+};
+
+struct rcar_dvdec {
+	struct v4l2_subdev sd;
+	struct v4l2_ctrl_handler hdl;
+	struct v4l2_rect rect;
+	v4l2_std_id norm;	/* Current set standard */
+	u32 input;
+	u32 output;
+	int enable;
+
+	bool			autodetect;
+	u32			in_cfmt;
+	const struct rcar_dvdec_color_format	*cfmt;
+	void __iomem *base;
+	u16			vsyncsr;
+};
+
+#define to_rcar_dvdec_sd(_ctrl) (&container_of(_ctrl->handler,		\
+					    struct rcar_dvdec,	\
+					    hdl)->sd)
+
+static inline struct rcar_dvdec *to_rcar_dvdec(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct rcar_dvdec, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct rcar_dvdec, hdl)->sd;
+}
+
+/*
+ * rcar_dvdec_s_input() - Select input pin
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @input: input pin(0:VIN1A, 1:VIN2A)
+ *
+ * Select and set input pin
+ */
+static int rcar_dvdec_s_input(struct v4l2_subdev *sd, u32 input)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	u16 adccr2;
+
+	if ((input & DVDEC_ADCCR2_ADC_VINSEL_MASK) != input) {
+		return -EINVAL;
+	}
+
+	adccr2 = ioread16(state->base + DVDEC_ADCCR2_REG);
+	adccr2 &= ~DVDEC_ADCCR2_ADC_VINSEL_MASK;
+	adccr2 |= input;
+	iowrite16(adccr2, state->base + DVDEC_ADCCR2_REG);
+
+	state->input = input;
+	return 0;
+}
+
+/*
+ * rcar_dvdec_s_output() - Select output direction
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @output: output id(0:VIN0, 1:VIN1)
+ *
+ * Select and set output direction.
+ */
+static int rcar_dvdec_s_output(struct v4l2_subdev *sd, u32 output)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	void __iomem *pmmr_reg;
+	void __iomem *adccr4_reg;
+
+	pmmr_reg = ioremap_nocache(DVDEC_PMMR_REG, 0x04);
+	adccr4_reg = ioremap_nocache(DVDEC_ADCCR4_REG, 0x04);
+
+	if (output == 0) {
+		writel_relaxed(~0x0001, pmmr_reg);
+		/* VIN0_SEL=1  (use VIN0-Module)*/
+		writel_relaxed(0x0001, adccr4_reg);
+	} else {
+		writel_relaxed(~0x0002, pmmr_reg);
+		/* VIN1_SEL=1  (use VIN1-Module)*/
+		writel_relaxed(0x0002, adccr4_reg);
+	}
+
+	iounmap(adccr4_reg);
+	iounmap(pmmr_reg);
+
+	state->output = output;
+	return 0;
+}
+
+/*
+ * rcar_dvdec_initcolor() - Init for each color format
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @sd: dvdec color format id
+ *
+ * Init recommendation setting of registers for each color format
+ */
+static void rcar_dvdec_initcolor(struct v4l2_subdev *sd, u32 dvdec_fmt)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+
+	/* V Update Enable for TGCR1 to TGCR3 */
+	iowrite16(0x8000, state->base + DVDEC_RUPDCR_REG);
+
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].TGCR1,
+		state->base + DVDEC_TGCR1_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].TGCR2,
+		state->base + DVDEC_TGCR2_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].TGCR3,
+		state->base + DVDEC_TGCR3_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].HAFCCR1,
+		state->base + DVDEC_HAFCCR1_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].HAFCCR2,
+		state->base + DVDEC_HAFCCR2_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].HAFCCR3,
+		state->base + DVDEC_HAFCCR3_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].VCDWCR1,
+		state->base + DVDEC_VCDWCR1_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].ACCCR1,
+		state->base + DVDEC_ACCCR1_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].AGCCR1,
+		state->base + DVDEC_AGCCR1_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR3,
+		state->base + DVDEC_YCSCR3_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR4,
+		state->base + DVDEC_YCSCR4_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR5,
+		state->base + DVDEC_YCSCR5_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR6,
+		state->base + DVDEC_YCSCR6_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR7,
+		state->base + DVDEC_YCSCR7_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR9,
+		state->base + DVDEC_YCSCR9_REG);
+	iowrite16(rcar_dvdec_reg_color[dvdec_fmt].YCSCR12,
+		state->base + DVDEC_YCSCR12_REG);
+
+	return;
+}
+
+/*
+ * rcar_dvdec_init2dYcNTSC() - Init coefficient for NTSC
+ * @sd: pointer to standard V4L2 sub-device structure
+ *
+ * Init Chroma filter TAP coefficients for NTSC
+ */
+static void rcar_dvdec_init2dYcNTSC(struct v4l2_subdev *sd)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	u16 val, mode, narrow;
+
+	val = ioread16(state->base + DVDEC_YCSCR12_REG);
+	mode   = val & DVDEC_YCSCR12_MODE_MASK;
+	narrow = val & DVDEC_YCSCR12_NARROW_MASK;
+
+	if (mode == DVDEC_YCSCR12_MODE_BYPASS)
+		return;
+
+	if (mode == DVDEC_YCSCR12_MODE_CASCADE) {
+		/* NTCS : Cascade Filter 1stage or 2stages */
+		iowrite16(24, state->base + DVDEC_YCTWA_F0_REG);
+		iowrite16(44, state->base + DVDEC_YCTWA_F1_REG);
+		iowrite16(20, state->base + DVDEC_YCTWA_F2_REG);
+		iowrite16(DVDEC_YCTMINUS|52, state->base + DVDEC_YCTWA_F3_REG);
+		iowrite16(DVDEC_YCTMINUS|128, state->base + DVDEC_YCTWA_F4_REG);
+		iowrite16(DVDEC_YCTMINUS|128, state->base + DVDEC_YCTWA_F5_REG);
+		iowrite16(DVDEC_YCTMINUS|12, state->base + DVDEC_YCTWA_F6_REG);
+		iowrite16(132, state->base + DVDEC_YCTWA_F7_REG);
+		iowrite16(200, state->base + DVDEC_YCTWA_F8_REG);
+
+		if (narrow == DVDEC_YCSCR12_NARROW_17TAP) {
+			/* NTCS : Cascade Filter 2stages */
+			iowrite16(24, state->base + DVDEC_YCTNA_F0_REG);
+			iowrite16(44, state->base + DVDEC_YCTNA_F1_REG);
+			iowrite16(20, state->base + DVDEC_YCTNA_F2_REG);
+			iowrite16(DVDEC_YCTMINUS|52,
+					state->base + DVDEC_YCTNA_F3_REG);
+			iowrite16(DVDEC_YCTMINUS|128,
+					state->base + DVDEC_YCTNA_F4_REG);
+			iowrite16(DVDEC_YCTMINUS|128,
+					state->base + DVDEC_YCTNA_F5_REG);
+			iowrite16(DVDEC_YCTMINUS|12,
+					state->base + DVDEC_YCTNA_F6_REG);
+			iowrite16(132, state->base + DVDEC_YCTNA_F7_REG);
+			iowrite16(200, state->base + DVDEC_YCTNA_F8_REG);
+		}
+	}
+
+	if (mode == DVDEC_YCSCR12_MODE_TAKEOFF) {
+		if (narrow == DVDEC_YCSCR12_NARROW_BYPASS) {
+			/* NTCS : TAKE-OFF Filter Broad-band */
+			iowrite16(0, state->base + DVDEC_YCTWA_F0_REG);
+			iowrite16(0, state->base + DVDEC_YCTWA_F1_REG);
+			iowrite16(0, state->base + DVDEC_YCTWA_F2_REG);
+			iowrite16(DVDEC_YCTMINUS|28,
+					state->base + DVDEC_YCTWA_F3_REG);
+			iowrite16(96, state->base + DVDEC_YCTWA_F4_REG);
+			iowrite16(228, state->base + DVDEC_YCTWA_F5_REG);
+			iowrite16(916, state->base + DVDEC_YCTWA_F6_REG);
+			iowrite16(204, state->base + DVDEC_YCTWA_F7_REG);
+			iowrite16(1648, state->base + DVDEC_YCTWA_F8_REG);
+		}
+
+		if (narrow == DVDEC_YCSCR12_NARROW_17TAP) {
+			/* NTCS : TAKE-OFF Filter Narrow-band */
+			iowrite16(0, state->base + DVDEC_YCTWA_F0_REG);
+			iowrite16(DVDEC_YCTMINUS|48,
+					state->base + DVDEC_YCTWA_F1_REG);
+			iowrite16(DVDEC_YCTMINUS|20,
+					state->base + DVDEC_YCTWA_F2_REG);
+			iowrite16(160, state->base + DVDEC_YCTWA_F3_REG);
+			iowrite16(232, state->base + DVDEC_YCTWA_F4_REG);
+			iowrite16(DVDEC_YCTMINUS|116,
+					state->base + DVDEC_YCTWA_F5_REG);
+			iowrite16(DVDEC_YCTMINUS|900,
+					state->base + DVDEC_YCTWA_F6_REG);
+			iowrite16(DVDEC_YCTMINUS|4,
+					state->base + DVDEC_YCTWA_F7_REG);
+			iowrite16(1392, state->base + DVDEC_YCTWA_F8_REG);
+		}
+	}
+}
+
+/*
+ * rcar_dvdec_init2dYcPAL() - Init coefficient for PAL
+ * @sd: pointer to standard V4L2 sub-device structure
+ *
+ * Init Chroma filter TAP coefficients for PAL
+ */
+static void rcar_dvdec_init2dYcPAL(struct v4l2_subdev *sd)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	u16 val, mode, narrow;
+
+	val = ioread16(state->base + DVDEC_YCSCR12_REG);
+	mode   = val & DVDEC_YCSCR12_MODE_MASK;
+	narrow = val & DVDEC_YCSCR12_NARROW_MASK;
+
+	if (mode == DVDEC_YCSCR12_MODE_BYPASS)
+		return;
+
+	if (mode == DVDEC_YCSCR12_MODE_CASCADE) {
+		/* NTCS : Cascade Filter 1stage or 2stages */
+		iowrite16(DVDEC_YCTMINUS|20, state->base + DVDEC_YCTWA_F0_REG);
+		iowrite16(24, state->base + DVDEC_YCTWA_F1_REG);
+		iowrite16(64, state->base + DVDEC_YCTWA_F2_REG);
+		iowrite16(40, state->base + DVDEC_YCTWA_F3_REG);
+		iowrite16(DVDEC_YCTMINUS|76, state->base + DVDEC_YCTWA_F4_REG);
+		iowrite16(DVDEC_YCTMINUS|164, state->base + DVDEC_YCTWA_F5_REG);
+		iowrite16(DVDEC_YCTMINUS|84, state->base + DVDEC_YCTWA_F6_REG);
+		iowrite16(108, state->base + DVDEC_YCTWA_F7_REG);
+		iowrite16(216, state->base + DVDEC_YCTWA_F8_REG);
+
+		if (narrow == DVDEC_YCSCR12_NARROW_17TAP) {
+			/* NTCS : Cascade Filter 2stages */
+			iowrite16(DVDEC_YCTMINUS|20,
+					state->base + DVDEC_YCTNA_F0_REG);
+			iowrite16(24, state->base + DVDEC_YCTNA_F1_REG);
+			iowrite16(64, state->base + DVDEC_YCTNA_F2_REG);
+			iowrite16(40, state->base + DVDEC_YCTNA_F3_REG);
+			iowrite16(DVDEC_YCTMINUS|76,
+					state->base + DVDEC_YCTNA_F4_REG);
+			iowrite16(DVDEC_YCTMINUS|164,
+					state->base + DVDEC_YCTNA_F5_REG);
+			iowrite16(DVDEC_YCTMINUS|84,
+					state->base + DVDEC_YCTNA_F6_REG);
+			iowrite16(108, state->base + DVDEC_YCTNA_F7_REG);
+			iowrite16(216, state->base + DVDEC_YCTNA_F8_REG);
+		}
+	}
+
+	if (mode == DVDEC_YCSCR12_MODE_TAKEOFF) {
+		if (narrow == DVDEC_YCSCR12_NARROW_BYPASS) {
+			/* NTCS : TAKE-OFF Filter Broad-band */
+			iowrite16(0, state->base + DVDEC_YCTWA_F0_REG);
+			iowrite16(0, state->base + DVDEC_YCTWA_F1_REG);
+			iowrite16(0, state->base + DVDEC_YCTWA_F2_REG);
+			iowrite16(16, state->base + DVDEC_YCTWA_F3_REG);
+			iowrite16(59, state->base + DVDEC_YCTWA_F4_REG);
+			iowrite16(85, state->base + DVDEC_YCTWA_F5_REG);
+			iowrite16(DVDEC_YCTMINUS|498,
+					state->base + DVDEC_YCTWA_F6_REG);
+			iowrite16(DVDEC_YCTMINUS|101,
+					state->base + DVDEC_YCTWA_F7_REG);
+			iowrite16(878, state->base + DVDEC_YCTWA_F8_REG);
+		}
+
+		if (narrow == DVDEC_YCSCR12_NARROW_17TAP) {
+			/* NTCS : TAKE-OFF Filter Narrow-band */
+			iowrite16(0, state->base + DVDEC_YCTWA_F0_REG);
+			iowrite16(0, state->base + DVDEC_YCTWA_F1_REG);
+			iowrite16(DVDEC_YCTMINUS|23,
+					state->base + DVDEC_YCTWA_F2_REG);
+			iowrite16(DVDEC_YCTMINUS|46,
+					state->base + DVDEC_YCTWA_F3_REG);
+			iowrite16(145, state->base + DVDEC_YCTWA_F4_REG);
+			iowrite16(409, state->base + DVDEC_YCTWA_F5_REG);
+			iowrite16(DVDEC_YCTMINUS|918,
+					state->base + DVDEC_YCTWA_F6_REG);
+			iowrite16(DVDEC_YCTMINUS|363,
+					state->base + DVDEC_YCTWA_F7_REG);
+			iowrite16(1592, state->base + DVDEC_YCTWA_F8_REG);
+		}
+	}
+}
+
+
+static int rcar_dvdec_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_rcar_dvdec_sd(ctrl);
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	int val, ret;
+
+	val = ctrl->val;
+	switch (ctrl->id) {
+	case V4L2_CID_CONTRAST:
+		if ((ctrl->val < DVDEC_YGAINCR_MIN) ||
+				(ctrl->val > DVDEC_YGAINCR_MAX))
+			ret = -ERANGE;
+		else
+			iowrite16(val, state->base + DVDEC_YGAINCR_REG);
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		if ((ctrl->val < DVDEC_CBGAINCR_MIN) ||
+				(ctrl->val > DVDEC_CBGAINCR_MAX))
+			ret = -ERANGE;
+		else
+			iowrite16(val, state->base + DVDEC_CBGAINCR_REG);
+		break;
+	case V4L2_CID_RED_BALANCE:
+		if ((ctrl->val < DVDEC_CRGAINCR_MIN) ||
+				(ctrl->val > DVDEC_CRGAINCR_MAX))
+			ret = -ERANGE;
+		else
+			iowrite16(val, state->base + DVDEC_CRGAINCR_REG);
+		break;
+	case V4L2_CID_USER_R8A7747X_INPUT:
+		rcar_dvdec_s_input(sd, ctrl->val);
+		break;
+	default:
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops rcar_dvdec_ctrl_ops = {
+	.s_ctrl = rcar_dvdec_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config rcar_dvdec_ctrls[] = {
+	{
+	.ops    = &rcar_dvdec_ctrl_ops,
+	.id             = V4L2_CID_USER_R8A7747X_INPUT,
+	.type   = V4L2_CTRL_TYPE_INTEGER,
+	.name   = "Set Input Id",
+	.min    = 0,
+	.max    = 1,
+	.step   = 1,
+/* IWG23S: VIN: set '0' -> VIN1A and set '1' -> VIN2A */
+	.def    = 0,
+	.flags  = 0,
+	}
+};
+
+/*
+ * rcar_dvdec_init_controls() - Init controls
+ * @state: pointer to private state structure
+ *
+ * Init rcar_dvdec supported control handler.
+ */
+static int rcar_dvdec_init_controls(struct rcar_dvdec *state)
+{
+	int i;
+
+	v4l2_ctrl_handler_init(&state->hdl,
+				ARRAY_SIZE(rcar_dvdec_ctrls) + 3);
+
+	v4l2_ctrl_new_std(&state->hdl, &rcar_dvdec_ctrl_ops,
+			  V4L2_CID_CONTRAST, DVDEC_YGAINCR_MIN,
+			  DVDEC_YGAINCR_MAX, 1, DVDEC_YGAINCR_DEF);
+	v4l2_ctrl_new_std(&state->hdl, &rcar_dvdec_ctrl_ops,
+			  V4L2_CID_BLUE_BALANCE, DVDEC_CBGAINCR_MIN,
+			  DVDEC_CBGAINCR_MAX, 1, DVDEC_CBGAINCR_DEF);
+	v4l2_ctrl_new_std(&state->hdl, &rcar_dvdec_ctrl_ops,
+			  V4L2_CID_RED_BALANCE, DVDEC_CRGAINCR_MIN,
+			  DVDEC_CRGAINCR_MAX, 1, DVDEC_CRGAINCR_DEF);
+	for (i = 0; i < ARRAY_SIZE(rcar_dvdec_ctrls); ++i)
+		v4l2_ctrl_new_custom(&state->hdl,
+					&rcar_dvdec_ctrls[i], NULL);
+
+	state->sd.ctrl_handler = &state->hdl;
+	if (state->hdl.error) {
+		int err = state->hdl.error;
+
+		v4l2_ctrl_handler_free(&state->hdl);
+		return err;
+	}
+	v4l2_ctrl_handler_setup(&state->hdl);
+
+	return 0;
+}
+
+/*
+ * rcar_dvdec_set_params() - Set parameters
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @width: pointer to width of input video
+ * @height: pointer to height of input video
+ * @code: V4l2 format code
+ *
+ * Set parameters of digital video decoder
+ */
+static int rcar_dvdec_set_params(struct v4l2_subdev *sd,
+			u32 *width, u32 *height, u32 code)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	int i;
+	u16 cromasr2;
+
+	/*
+	 * select format
+	 */
+	for (i = 0; i < ARRAY_SIZE(rcar_dvdec_cfmts); i++) {
+		if (code == rcar_dvdec_cfmts[i].code) {
+			state->cfmt = rcar_dvdec_cfmts + i;
+			break;
+		}
+	}
+	if (i >= ARRAY_SIZE(rcar_dvdec_cfmts))
+		return -EINVAL;			/* no match format */
+
+	cromasr2 = ioread16(state->base + DVDEC_CROMASR2_REG);
+	if (cromasr2 & DVDEC_CROMASR2_ISNTSC) {
+		dev_info(sd->dev, "Detected the NTSC video input signal\n");
+		rcar_dvdec_init2dYcNTSC(sd);
+	} else if (cromasr2 & DVDEC_CROMASR2_ISPAL) {
+		dev_info(sd->dev, "Detected the PAL video input signal\n");
+		rcar_dvdec_init2dYcPAL(sd);
+	} else if (cromasr2 & DVDEC_CROMASR2_ISSECAM) {
+		/* SECAM is not supported */
+		dev_info(sd->dev, "Detected the SECAM video input signal\n");
+	} else {
+		dev_info(sd->dev, "Not detect any video input signal\n");
+	}
+
+	/*
+	 * set window size
+	 */
+	*width  = rcar_dvdec_rect[state->in_cfmt].width;
+	*height = rcar_dvdec_rect[state->in_cfmt].height;
+
+	return 0;
+}
+
+/*
+ * rcar_dvdec_to_v4l2_std() - Decide V4L2 video standard
+ * @sd: ptr to v4l2_subdev struct
+ * @cromasr1: Chroma Decoding Read Register 1 value
+ * @vsyncsr: Sync Separation Status/Vertical Cycle Read Registar value
+ *
+ * Decide V4l2 video standard from the digital video decoder register
+ */
+static v4l2_std_id rcar_dvdec_to_v4l2_std(struct v4l2_subdev *sd,
+	u16 cromasr1, u16 vsyncsr)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	v4l2_std_id std;
+
+	/* SECAM or UNDETECTABLE */
+	std = V4L2_STD_UNKNOWN;
+
+	state->vsyncsr = (vsyncsr & DVDEC_VSYNCSR_FVMODE_MASK);
+	switch (cromasr1 & DVDEC_CROMASR1_COLORSYS_MASK) {
+	case DVDEC_CROMASR1_COLORSYS_NTSC:
+		switch (cromasr1 & DVDEC_CROMASR1_FSCMODE_MASK) {
+		case DVDEC_CROMASR1_FSCMODE_358:
+			/* NTSC-M */
+			dev_info(sd->dev, "Detected NTSC 358\n");
+			std = V4L2_STD_NTSC;
+			break;
+
+		case DVDEC_CROMASR1_FSCMODE_443:
+			/* NTSC-4.43 */
+			std = V4L2_STD_NTSC_443;
+			switch	(vsyncsr & DVDEC_VSYNCSR_FVMODE_MASK) {
+			case DVDEC_VSYNCSR_FVMODE_50:
+				dev_info(sd->dev, "Detected PAL443 50Hz\n");
+				break;
+
+			case DVDEC_VSYNCSR_FVMODE_60:
+				dev_info(sd->dev, "Detected PAL443 60Hz\n");
+				break;
+			}
+			break;
+		}
+		break;
+
+	case DVDEC_CROMASR1_COLORSYS_PAL:
+		switch (cromasr1 & DVDEC_CROMASR1_FSCMODE_MASK) {
+		case DVDEC_CROMASR1_FSCMODE_358:
+			switch	(vsyncsr & DVDEC_VSYNCSR_FVMODE_MASK) {
+			case DVDEC_VSYNCSR_FVMODE_50:
+				/* PAL-N */
+				dev_info(sd->dev, "Detected PALN\n");
+				std = V4L2_STD_PAL_N;
+				break;
+
+			case DVDEC_VSYNCSR_FVMODE_60:
+				/* PAL-M */
+				dev_info(sd->dev, "Detected PALM\n");
+				std = V4L2_STD_PAL_M;
+				break;
+			}
+			break;
+
+		case DVDEC_CROMASR1_FSCMODE_443:
+			switch (vsyncsr & DVDEC_VSYNCSR_FVMODE_MASK) {
+			case DVDEC_VSYNCSR_FVMODE_50:
+				/* PAL-4.43 */
+				dev_info(sd->dev, "Detected PAL443\n");
+				std = V4L2_STD_PAL;
+				break;
+
+			case DVDEC_VSYNCSR_FVMODE_60:
+				/* PAL-60 */
+				dev_info(sd->dev, "Detected PAL60\n");
+				std = V4L2_STD_PAL_60;
+				break;
+			}
+		}
+	}
+
+	return std;
+}
+
+/*
+ * v4l2_std_to_rcar_dvdec_id() - Decide control value
+ * @v4l2_std_id: V4l2 video standard id
+ *
+ * Convert V4l2 video standard id to private id
+ */
+static u32 v4l2_std_to_rcar_dvdec_id(
+	struct rcar_dvdec *state, v4l2_std_id std)
+{
+	if (std == V4L2_STD_NTSC)
+		return DVDEC_NTSC358;
+	if (std == V4L2_STD_NTSC_443) {
+		if (state->vsyncsr == DVDEC_VSYNCSR_FVMODE_50)
+			return DVDEC_NTSC443;
+		else
+			return DVDEC_NTSC60;
+	}
+	if (std == V4L2_STD_PAL)
+		return DVDEC_PAL443;
+	if (std == V4L2_STD_PAL_M)
+		return DVDEC_PALM;
+	if (std == V4L2_STD_PAL_N)
+		return DVDEC_PALN;
+	if (std & V4L2_STD_PAL_60)
+		return DVDEC_PAL60;
+
+	return DVDEC_NTSC358;
+}
+
+/*
+ * __rcar_dvdec_status() - get digital video decoder status
+ * @sd: ptr to v4l2_subdev struct
+ * @status: input status
+ * @std: V4l2 video standard
+ *
+ * Get status and/or V4l2 video standard
+ */
+static int __rcar_dvdec_status(
+	struct v4l2_subdev *sd, u32 *status, v4l2_std_id *std)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	u16 val, cromasr1, vsyncsr;
+
+	/* Set auto detection mode */
+	val = ioread16(state->base + DVDEC_VCDWCR1_REG);
+	val &= ~DVDEC_VCDWCR1_AMASK;
+	val |= DVDEC_VCDWCR1_AUTO;
+	iowrite16(val, state->base + DVDEC_VCDWCR1_REG);
+
+	cromasr1 = ioread16(state->base + DVDEC_CROMASR1_REG);
+	vsyncsr  = ioread16(state->base + DVDEC_VSYNCSR_REG);
+	if (status) {
+		if (vsyncsr & DVDEC_VSYNCSR_NOSIGNAL)
+			*status = V4L2_IN_ST_NO_SIGNAL;
+		else
+			*status = 0;
+	}
+	if (std) {
+		*std = rcar_dvdec_to_v4l2_std(sd, cromasr1, vsyncsr);
+		state->in_cfmt = v4l2_std_to_rcar_dvdec_id(state, *std);
+		rcar_dvdec_initcolor(sd, state->in_cfmt);
+	}
+
+	return 0;
+}
+
+/*
+ * v4l2_std_to_rcar_dvdec() - Decide control value
+ * @v4l2_std_id: V4l2 video standard id
+ *
+ * Convert V4l2 video standard id to the control value of
+ * the digital video decoder.
+ */
+static u16 v4l2_std_to_rcar_dvdec(v4l2_std_id std)
+{
+	if (std == V4L2_STD_NTSC)
+		return DVDEC_BTLCR_DETECT_NTSC_M;
+	if (std == V4L2_STD_NTSC_443)
+		return DVDEC_BTLCR_DETECT_NTSC_443;
+	if (std == V4L2_STD_PAL)
+		return DVDEC_BTLCR_DETECT_PAL_443;
+	if (std == V4L2_STD_PAL_M)
+		return DVDEC_BTLCR_DETECT_PAL_M;
+	if (std == V4L2_STD_PAL_N)
+		return DVDEC_BTLCR_DETECT_PAL_N;
+	if (std & V4L2_STD_PAL_60)
+		return DVDEC_BTLCR_DETECT_PAL_60;
+
+	return DVDEC_BTLCR_DETECT_AUTO;
+}
+
+/*
+ * init_device - Init a digital video decoder
+ * @sd: pointer to v4l2_subdev structure
+ * @state: pointer to private state structure
+ *
+ * Initialize the digital video decoder
+ */
+static int init_device(struct v4l2_subdev *sd, struct rcar_dvdec *state)
+{
+	int ret;
+	u16 val;
+
+	iowrite16(DVDEC_ADCCR1_INIT, state->base + DVDEC_ADCCR1_REG);
+
+	iowrite16(DVDEC_SYNSCR1_INIT, state->base + DVDEC_SYNSCR1_REG);
+	iowrite16(DVDEC_SYNSCR2_INIT, state->base + DVDEC_SYNSCR2_REG);
+	iowrite16(DVDEC_SYNSCR3_INIT, state->base + DVDEC_SYNSCR3_REG);
+	iowrite16(DVDEC_SYNSCR4_INIT, state->base + DVDEC_SYNSCR4_REG);
+	iowrite16(DVDEC_SYNSCR5_INIT, state->base + DVDEC_SYNSCR5_REG);
+
+	iowrite16(DVDEC_HAFCCR1_INIT, state->base + DVDEC_HAFCCR1_REG);
+	iowrite16(DVDEC_HAFCCR2_INIT, state->base + DVDEC_HAFCCR2_REG);
+	iowrite16(DVDEC_HAFCCR3_INIT, state->base + DVDEC_HAFCCR3_REG);
+
+	val = ioread16(state->base + DVDEC_VCDWCR1_REG);
+	val &= ~DVDEC_VCDWCR1_IMASK;
+	val |= DVDEC_VCDWCR1_INIT;
+	iowrite16(val, state->base + DVDEC_VCDWCR1_REG);
+
+	iowrite16(DVDEC_DCPCR1_INIT, state->base + DVDEC_DCPCR1_REG);
+	iowrite16(DVDEC_DCPCR2_INIT, state->base + DVDEC_DCPCR2_REG);
+	iowrite16(DVDEC_DCPCR3_INIT, state->base + DVDEC_DCPCR3_REG);
+	iowrite16(DVDEC_DCPCR4_INIT, state->base + DVDEC_DCPCR4_REG);
+	iowrite16(DVDEC_DCPCR5_INIT, state->base + DVDEC_DCPCR5_REG);
+	iowrite16(DVDEC_DCPCR6_INIT, state->base + DVDEC_DCPCR6_REG);
+	iowrite16(DVDEC_DCPCR7_INIT, state->base + DVDEC_DCPCR7_REG);
+	iowrite16(DVDEC_DCPCR8_INIT, state->base + DVDEC_DCPCR8_REG);
+
+	iowrite16(DVDEC_NSDCR_INIT, state->base + DVDEC_NSDCR_REG);
+
+	/* Enable autodetection */
+	if (state->autodetect) {
+		iowrite16(DVDEC_BTLCR_INIT | DVDEC_BTLCR_DETECT_AUTO,
+					state->base + DVDEC_BTLCR_REG);
+	} else {
+		ret = v4l2_std_to_rcar_dvdec(state->norm);
+		iowrite16(DVDEC_BTLCR_INIT | (u16)ret,
+				state->base + DVDEC_BTLCR_REG);
+	}
+
+	iowrite16(DVDEC_BTGPCR_INIT, state->base + DVDEC_BTGPCR_REG);
+
+	iowrite16(DVDEC_ACCCR1_INIT, state->base + DVDEC_ACCCR1_REG);
+	iowrite16(DVDEC_ACCCR2_INIT, state->base + DVDEC_ACCCR2_REG);
+	iowrite16(DVDEC_ACCCR3_INIT, state->base + DVDEC_ACCCR3_REG);
+
+	iowrite16(DVDEC_TINTCR_INIT, state->base + DVDEC_TINTCR_REG);
+	iowrite16(DVDEC_YCDCR_INIT, state->base + DVDEC_YCDCR_REG);
+
+	iowrite16(DVDEC_AGCCR1_INIT, state->base + DVDEC_AGCCR1_REG);
+
+	val = ioread16(state->base + DVDEC_AGCCR2_REG);
+	val &= ~DVDEC_AGCCR2_IMASK;
+	val |= DVDEC_AGCCR2_INIT;
+	iowrite16(val, state->base + DVDEC_AGCCR2_REG);
+
+	iowrite16(DVDEC_PKLIMITCR_INIT, state->base + DVDEC_PKLIMITCR_REG);
+
+	iowrite16(DVDEC_RGORCR1_INIT, state->base + DVDEC_RGORCR1_REG);
+	iowrite16(DVDEC_RGORCR2_INIT, state->base + DVDEC_RGORCR2_REG);
+	iowrite16(DVDEC_RGORCR3_INIT, state->base + DVDEC_RGORCR3_REG);
+	iowrite16(DVDEC_RGORCR4_INIT, state->base + DVDEC_RGORCR4_REG);
+	iowrite16(DVDEC_RGORCR5_INIT, state->base + DVDEC_RGORCR5_REG);
+	iowrite16(DVDEC_RGORCR6_INIT, state->base + DVDEC_RGORCR6_REG);
+	iowrite16(DVDEC_RGORCR7_INIT, state->base + DVDEC_RGORCR7_REG);
+
+	iowrite16(DVDEC_AFCPFCR_INIT, state->base + DVDEC_AFCPFCR_REG);
+	iowrite16(DVDEC_RUPDCR_INIT, state->base + DVDEC_RUPDCR_REG);
+	iowrite16(DVDEC_YCSCR8_INIT, state->base + DVDEC_YCSCR8_REG);
+	iowrite16(DVDEC_YCSCR11_INIT, state->base + DVDEC_YCSCR11_REG);
+	iowrite16(DVDEC_DCPCR9_INIT, state->base + DVDEC_DCPCR9_REG);
+
+	iowrite16(DVDEC_YGAINCR_INIT, state->base + DVDEC_YGAINCR_REG);
+	iowrite16(DVDEC_CBGAINCR_INIT, state->base + DVDEC_CBGAINCR_REG);
+	iowrite16(DVDEC_CRGAINCR_INIT, state->base + DVDEC_CRGAINCR_REG);
+
+	iowrite16(DVDEC_PGA_UPDATE_INIT, state->base + DVDEC_PGA_UPDATE_REG);
+	iowrite16(DVDEC_PGACR_INIT, state->base + DVDEC_PGACR_REG);
+
+	rcar_dvdec_s_input(sd, 0);
+	/* read current norm */
+	__rcar_dvdec_status(sd, NULL, &state->norm);
+
+	/* Select VIN0 as output direction */
+	ret = rcar_dvdec_s_output(sd, 0);
+
+	return ret;
+}
+
+/****************************************************************************
+			Basic functions
+ ****************************************************************************/
+static int rcar_dvdec_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)
+{
+	struct rcar_dvdec *decoder = to_rcar_dvdec(sd);
+
+	*norm = decoder->norm;
+
+	return 0;
+}
+
+static int rcar_dvdec_g_tvnorms(struct v4l2_subdev *sd, v4l2_std_id *norm)
+{
+	*norm = V4L2_STD_ALL;
+	return 0;
+}
+
+static int rcar_dvdec_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	int ret = 0;
+	u16 val, dvdec_color;
+
+	/* all standards -> autodetect */
+	if (std == V4L2_STD_ALL) {
+		val = ioread16(state->base + DVDEC_BTLCR_REG);
+		val &= ~DVDEC_BTLCR_DETECT_MASK;
+		val |= DVDEC_BTLCR_DETECT_AUTO;
+		iowrite16(val, state->base + DVDEC_BTLCR_REG);
+
+		__rcar_dvdec_status(sd, NULL, &state->norm);
+		state->autodetect = true;
+	} else {
+		dvdec_color = v4l2_std_to_rcar_dvdec(std);
+
+		val = ioread16(state->base + DVDEC_BTLCR_REG);
+		val &= ~DVDEC_BTLCR_DETECT_MASK;
+		val |= dvdec_color;
+		iowrite16(val, state->base + DVDEC_BTLCR_REG);
+
+		state->norm = std;
+		state->autodetect = false;
+	}
+
+	return ret;
+}
+
+static int rcar_dvdec_reset(struct v4l2_subdev *sd, u32 val)
+{
+
+	return 0;
+};
+
+static int rcar_dvdec_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index)
+		return -EINVAL;
+
+	code->code = rcar_dvdec_cfmts[0].code;
+
+	return 0;
+}
+
+static int rcar_dvdec_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	mf = &format->format;
+	if (!state->cfmt)
+		state->cfmt = rcar_dvdec_cfmts;
+
+	mf->width	= rcar_dvdec_rect[state->in_cfmt].width;
+	mf->height	= rcar_dvdec_rect[state->in_cfmt].height;
+	mf->code	= state->cfmt->code;
+	mf->colorspace	= state->cfmt->colorspace;
+	mf->field	= V4L2_FIELD_INTERLACED;
+
+	return 0;
+}
+
+static int rcar_dvdec_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *f;
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	int ret;
+
+	f = &format->format;
+	ret = rcar_dvdec_set_params(sd, &f->width, &f->height, f->code);
+	if (!ret)
+		f->colorspace = state->cfmt->colorspace;
+
+	return ret;
+}
+
+
+static int rcar_dvdec_g_mbus_config(struct v4l2_subdev *sd,
+		struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING |
+		V4L2_MBUS_VSYNC_ACTIVE_LOW | V4L2_MBUS_HSYNC_ACTIVE_LOW |
+		V4L2_MBUS_DATA_ACTIVE_HIGH | V4L2_MBUS_MASTER;
+	cfg->type = V4L2_MBUS_BT656;
+	return 0;
+}
+
+static int rcar_dvdec_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+
+	a->c.left = rcar_dvdec_rect[state->in_cfmt].left;
+	a->c.top = rcar_dvdec_rect[state->in_cfmt].top;
+	/* set current window size */
+	a->c.width = rcar_dvdec_rect[state->in_cfmt].width;
+	a->c.height = rcar_dvdec_rect[state->in_cfmt].height;
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+/*
+ * rcar_dvdec_cropcap() - V4L2 decoder i/f handler for cropcap
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @a: pointer to standard V4L2 cropcap structure
+ *
+ * Gets cropping limits, default cropping rectangle and pixel aspect.
+ */
+static int rcar_dvdec_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+
+	a->bounds.left = rcar_dvdec_rect[state->in_cfmt].left;
+	a->bounds.top = rcar_dvdec_rect[state->in_cfmt].top;
+	/* set maximum window size */
+	a->bounds.width = rcar_dvdec_rect[state->in_cfmt].width;
+	a->bounds.height = rcar_dvdec_rect[state->in_cfmt].height;
+	a->defrect = a->bounds;
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator = 1;
+	a->pixelaspect.denominator = 1;
+
+	return 0;
+}
+static int rcar_dvdec_s_routing(struct v4l2_subdev *sd,
+			     u32 input, u32 output, u32 config)
+{
+	struct rcar_dvdec *decoder = to_rcar_dvdec(sd);
+
+	decoder->input = input;
+	decoder->output = output;
+	return 0;
+}
+
+static int rcar_dvdec_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)
+{
+	struct rcar_dvdec *state = to_rcar_dvdec(sd);
+	int err = 0;
+
+	if (err)
+		return err;
+
+	/* when we are interrupt driven we know the state */
+	if (!state->autodetect)
+		*std = state->norm;
+	else
+		err = __rcar_dvdec_status(sd, NULL, std);
+
+	return err;
+}
+
+/* ----------------------------------------------------------------------- */
+static const struct v4l2_subdev_core_ops rcar_dvdec_core_ops = {
+	.reset = rcar_dvdec_reset,
+};
+
+static const struct v4l2_subdev_video_ops rcar_dvdec_video_ops = {
+	.s_std = rcar_dvdec_s_std,
+	.s_routing = rcar_dvdec_s_routing,
+	.g_crop = rcar_dvdec_g_crop,
+	.cropcap = rcar_dvdec_cropcap,
+	.g_std = rcar_dvdec_g_std,
+	.g_tvnorms = rcar_dvdec_g_tvnorms,
+	.g_mbus_config = rcar_dvdec_g_mbus_config,
+	.querystd = rcar_dvdec_querystd,
+};
+
+static const struct v4l2_subdev_pad_ops rcar_dvdec_pad_ops = {
+	.enum_mbus_code = rcar_dvdec_enum_mbus_code,
+	.set_fmt = rcar_dvdec_set_fmt,
+	.get_fmt = rcar_dvdec_get_fmt,
+};
+
+static const struct v4l2_subdev_ops rcar_dvdec_ops = {
+	.core = &rcar_dvdec_core_ops,
+	.video = &rcar_dvdec_video_ops,
+	.pad = &rcar_dvdec_pad_ops,
+};
+
+static struct resource dvdec_resource[] = {
+	DEFINE_RES_MEM(0xfeb81000, 0x2000),
+};
+
+/****************************************************************************
+			I2C Client & Driver
+ ****************************************************************************/
+
+static int rcar_dvdec_probe(struct i2c_client *c,
+			 const struct i2c_device_id *id)
+{
+	struct rcar_dvdec *core;
+	struct v4l2_subdev *sd;
+	int ret;
+	struct clk *clk;
+
+	core = devm_kzalloc(&c->dev, sizeof(*core), GFP_KERNEL);
+	if (!core)
+		return -ENOMEM;
+	sd = &core->sd;
+
+	/* Enable dvdec module when probing */
+	clk = devm_clk_get(&c->dev, NULL);
+	if (IS_ERR(clk))
+		dev_err(&c->dev, "no clock for DVDEC \n");
+	else
+		clk_prepare_enable(clk);
+
+	/*  Get resource  */
+	core->base = devm_ioremap_resource(&c->dev, &dvdec_resource[0]);
+	if (IS_ERR(core->base)) {
+		dev_err(&c->dev, "Failed to remap resource\n");
+		ret = PTR_ERR(core->base);
+		return ret;
+	}
+
+	core->norm = V4L2_STD_ALL;	/*check:why Default is autodetect */
+	core->autodetect = true;
+	core->input = 0;
+	core->output = 0;
+	core->in_cfmt = DVDEC_NTSC358;
+	core->cfmt = &rcar_dvdec_cfmts[0];
+	/* Default is no cropping */
+	core->rect.top = 16;
+	core->rect.left = 0;
+
+	v4l2_i2c_subdev_init(sd, c, &rcar_dvdec_ops);
+	ret = rcar_dvdec_init_controls(core);
+	if (ret) {
+		dev_err(&c->dev, "Failed to init controls\n");
+		goto err;
+	}
+
+	/* clock supply to the A/D converter */
+	iowrite16(DVDEC_PSAV_ON, core->base + DVDEC_ADCCR3_REG);
+
+	ret = init_device(sd, core);
+	if (ret) {
+		dev_err(&c->dev, "Failed to init device\n");
+	}
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+
+err:
+	v4l2_ctrl_handler_free(&core->hdl);
+	return ret;
+}
+
+static int rcar_dvdec_remove(struct i2c_client *c)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(c);
+	struct rcar_dvdec *decoder = to_rcar_dvdec(sd);
+
+	v4l2_dbg(1, debug, sd,
+		"rcar_dvdec.c: removing rcar_dvdec adapter on address 0x%x\n",
+		c->addr << 1);
+
+	v4l2_async_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(&decoder->hdl);
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static const struct i2c_device_id rcar_dvdec_id[] = {
+	{ "rcar-dvdec", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, rcar_dvdec_id);
+
+static struct i2c_driver rcar_dvdec_driver = {
+	.driver = {
+		.name	= "rcar-dvdec",
+	},
+	.probe		= rcar_dvdec_probe,
+	.remove		= rcar_dvdec_remove,
+	.id_table	= rcar_dvdec_id,
+};
+
+module_i2c_driver(rcar_dvdec_driver);
\ No newline at end of file
diff --git a/drivers/media/platform/rcar-dvdec.h b/drivers/media/platform/rcar-dvdec.h
new file mode 100644
index 0000000..266906c
--- /dev/null
+++ b/drivers/media/platform/rcar-dvdec.h
@@ -0,0 +1,403 @@
+/*
+ * drivers/media/platform/rcar-dvdec.h
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef _RCAR_DVDEC_H_
+#define _RCAR_DVDEC_H_
+
+#define V4L2_CID_USER_R8A7794X_INPUT	(V4L2_CID_USER_R8A7794X_BASE + 0)
+#define V4L2_CID_USER_R8A7747X_INPUT	(V4L2_CID_USER_R8A7747X_BASE + 0)
+
+struct reg_color {
+	u16 TGCR1;
+	u16 TGCR2;
+	u16 TGCR3;
+	u16 HAFCCR1;
+	u16 HAFCCR2;
+	u16 HAFCCR3;
+	u16 VCDWCR1;
+	u16 BTLCR;
+	u16 ACCCR1;
+	u16 AGCCR1;
+	u16 YCSCR3;
+	u16 YCSCR4;
+	u16 YCSCR5;
+	u16 YCSCR6;
+	u16 YCSCR7;
+	u16 YCSCR9;
+	u16 YCSCR12;
+};
+
+struct dvdec_rect {
+	u32 top;
+	u32 height;
+	u32 left;
+	u32 width;
+};
+
+/* Color Format Id */
+#define DVDEC_NTSC358	0
+#define DVDEC_NTSC443	1
+#define DVDEC_PAL443	2
+#define DVDEC_PALM	3
+#define DVDEC_PALN	4
+#define DVDEC_SECAM	5
+#define DVDEC_NTSC60	6
+#define DVDEC_PAL60	7
+
+/* Address of 24D. Digital Video Decoder registers  */
+/* Offset value from 0xFEB81000 */
+#define DVDEC_ADCCR1_REG			0x008
+#define DVDEC_TGCR1_REG				0x00E
+#define DVDEC_TGCR2_REG				0x010
+#define DVDEC_TGCR3_REG				0x012
+#define DVDEC_SYNSCR1_REG			0x01A
+#define DVDEC_SYNSCR2_REG			0x01C
+#define DVDEC_SYNSCR3_REG			0x01E
+#define DVDEC_SYNSCR4_REG			0x020
+#define DVDEC_SYNSCR5_REG			0x022
+#define DVDEC_HAFCCR1_REG			0x024
+#define DVDEC_HAFCCR2_REG			0x026
+#define DVDEC_HAFCCR3_REG			0x028
+#define DVDEC_VCDWCR1_REG			0x02A
+#define DVDEC_DCPCR1_REG			0x030
+#define DVDEC_DCPCR2_REG			0x032
+#define DVDEC_DCPCR3_REG			0x034
+#define DVDEC_DCPCR4_REG			0x036
+#define DVDEC_DCPCR5_REG			0x038
+#define DVDEC_DCPCR6_REG			0x03A
+#define DVDEC_DCPCR7_REG			0x03C
+#define DVDEC_DCPCR8_REG			0x03E
+#define DVDEC_NSDCR_REG				0x040
+#define DVDEC_BTLCR_REG				0x042
+#define DVDEC_BTGPCR_REG			0x044
+#define DVDEC_ACCCR1_REG			0x046
+#define DVDEC_ACCCR2_REG			0x048
+#define DVDEC_ACCCR3_REG			0x04A
+#define DVDEC_TINTCR_REG			0x04C
+#define DVDEC_YCDCR_REG				0x04E
+#define DVDEC_AGCCR1_REG			0x050
+#define DVDEC_AGCCR2_REG			0x052
+#define DVDEC_PKLIMITCR_REG			0x054
+#define DVDEC_RGORCR1_REG			0x056
+#define DVDEC_RGORCR2_REG			0x058
+#define DVDEC_RGORCR3_REG			0x05A
+#define DVDEC_RGORCR4_REG			0x05C
+#define DVDEC_RGORCR5_REG			0x05E
+#define DVDEC_RGORCR6_REG			0x060
+#define DVDEC_RGORCR7_REG			0x062
+
+#define DVDEC_AFCPFCR_REG			0x07C
+#define DVDEC_RUPDCR_REG			0x07E
+#define DVDEC_VSYNCSR_REG			0x080
+#define DVDEC_HSYNCSR_REG			0x082
+#define DVDEC_DCPSR1_REG			0x084
+#define DVDEC_DCPSR2_REG			0x086
+#define DVDEC_NSDSR_REG				0x08C
+#define DVDEC_CROMASR1_REG			0x08E
+#define DVDEC_CROMASR2_REG			0x090
+#define DVDEC_SYNCSSR_REG			0x092
+#define DVDEC_AGCCSR1_REG			0x094
+#define DVDEC_AGCCSR2_REG			0x096
+
+#define DVDEC_YCSCR3_REG			0x104
+#define DVDEC_YCSCR4_REG			0x106
+#define DVDEC_YCSCR5_REG			0x108
+#define DVDEC_YCSCR6_REG			0x10A
+#define DVDEC_YCSCR7_REG			0x10C
+#define DVDEC_YCSCR8_REG			0x10E
+#define DVDEC_YCSCR9_REG			0x110
+#define DVDEC_YCSCR11_REG			0x114
+#define DVDEC_YCSCR12_REG			0x116
+
+#define DVDEC_DCPCR9_REG			0x180
+
+#define DVDEC_YCTWA_F0_REG			0x192
+#define DVDEC_YCTWA_F1_REG			0x194
+#define DVDEC_YCTWA_F2_REG			0x196
+#define DVDEC_YCTWA_F3_REG			0x198
+#define DVDEC_YCTWA_F4_REG			0x19A
+#define DVDEC_YCTWA_F5_REG			0x19C
+#define DVDEC_YCTWA_F6_REG			0x19E
+#define DVDEC_YCTWA_F7_REG			0x1A0
+#define DVDEC_YCTWA_F8_REG			0x1A2
+#define DVDEC_YCTWB_F0_REG			0x1A4
+#define DVDEC_YCTWB_F1_REG			0x1A6
+#define DVDEC_YCTWB_F2_REG			0x1A8
+#define DVDEC_YCTWB_F3_REG			0x1AA
+#define DVDEC_YCTWB_F4_REG			0x1AC
+#define DVDEC_YCTWB_F5_REG			0x1AE
+#define DVDEC_YCTWB_F6_REG			0x1B0
+#define DVDEC_YCTWB_F7_REG			0x1B2
+#define DVDEC_YCTWB_F8_REG			0x1B4
+#define DVDEC_YCTNA_F0_REG			0x1B6
+#define DVDEC_YCTNA_F1_REG			0x1B8
+#define DVDEC_YCTNA_F2_REG			0x1BA
+#define DVDEC_YCTNA_F3_REG			0x1BC
+#define DVDEC_YCTNA_F4_REG			0x1BE
+#define DVDEC_YCTNA_F5_REG			0x1C0
+#define DVDEC_YCTNA_F6_REG			0x1C2
+#define DVDEC_YCTNA_F7_REG			0x1C4
+#define DVDEC_YCTNA_F8_REG			0x1C6
+#define DVDEC_YCTNB_F0_REG			0x1C8
+#define DVDEC_YCTNB_F1_REG			0x1CA
+#define DVDEC_YCTNB_F2_REG			0x1CC
+#define DVDEC_YCTNB_F3_REG			0x1CE
+#define DVDEC_YCTNB_F4_REG			0x1D0
+#define DVDEC_YCTNB_F5_REG			0x1D2
+#define DVDEC_YCTNB_F6_REG			0x1D4
+#define DVDEC_YCTNB_F7_REG			0x1D6
+#define DVDEC_YCTNB_F8_REG			0x1D8
+
+#define DVDEC_YGAINCR_REG			0x200
+#define DVDEC_CBGAINCR_REG			0x202
+#define DVDEC_CRGAINCR_REG			0x204
+
+#define DVDEC_PGA_UPDATE_REG			0x280
+#define DVDEC_PGACR_REG				0x282
+#define DVDEC_ADCCR2_REG			0x284
+#define DVDEC_ADCCR3_REG			0x286
+
+
+#define DVDEC_PMMR_REG				0xE6060000
+#define DVDEC_ADCCR4_REG			0xE60600CC
+#define MSTP8_REG					0xE6150990
+#define MSTP8_DVDEC_MASK			0xFFFFF7FD
+
+/* Burst Lock/Chroma Decoding Control Register */
+#define DVDEC_BTLCR_DETECT_MASK			0x00FF
+#define DVDEC_BTLCR_DETECT_AUTO			0x00C0
+#define DVDEC_BTLCR_DETECT_NTSC_M		0x001F
+#define DVDEC_BTLCR_DETECT_NTSC_443		0x002F
+#define DVDEC_BTLCR_DETECT_PAL_443		0x007D
+#define DVDEC_BTLCR_DETECT_PAL_M		0x0077
+#define DVDEC_BTLCR_DETECT_PAL_N		0x007B
+#define DVDEC_BTLCR_DETECT_PAL_60		0x007D
+#define DVDEC_BTLCR_DETECT_SECAM		0x00BE
+
+#define DVDEC_CROMASR1_COLORSYS_MASK		0xC000
+#define DVDEC_CROMASR1_COLORSYS_NTSC		0x0000
+#define DVDEC_CROMASR1_COLORSYS_PAL		0x4000
+#define DVDEC_CROMASR1_COLORSYS_SECAM		0x8000
+#define DVDEC_CROMASR1_COLORSYS_UNDETECTABLE	0xC000
+
+#define DVDEC_CROMASR1_FSCMODE_MASK		0x2000
+#define DVDEC_CROMASR1_FSCMODE_358		0x0000
+#define DVDEC_CROMASR1_FSCMODE_443		0x2000
+
+#define DVDEC_CROMASR2_ISSECAM			0x1000
+#define DVDEC_CROMASR2_ISPAL			0x0800
+#define DVDEC_CROMASR2_ISNTSC			0x0400
+
+#define DVDEC_VSYNCSR_NOSIGNAL			0x0800
+#define DVDEC_VSYNCSR_FVMODE_MASK		0x0200
+#define DVDEC_VSYNCSR_FVMODE_50			0x0000
+#define DVDEC_VSYNCSR_FVMODE_60			0x0200
+
+#define DVDEC_YCTMINUS				0x1000
+
+/* CONTRAST */
+#define DVDEC_YGAINCR_MIN	0
+#define DVDEC_YGAINCR_DEF	816
+#define DVDEC_YGAINCR_MAX	1023
+/* BLUE BALANCE */
+#define DVDEC_CBGAINCR_MIN	0
+#define DVDEC_CBGAINCR_DEF	663
+#define DVDEC_CBGAINCR_MAX	1023
+/* RED BALANCE */
+#define DVDEC_CRGAINCR_MIN	0
+#define DVDEC_CRGAINCR_DEF	663
+#define DVDEC_CRGAINCR_MAX	1023
+
+#define DVDEC_YCSCR12_MODE_MASK			0x000C
+#define DVDEC_YCSCR12_MODE_BYPASS		0x0000
+#define DVDEC_YCSCR12_MODE_CASCADE		0x0004
+#define DVDEC_YCSCR12_MODE_TAKEOFF		0x0008
+
+#define DVDEC_YCSCR12_NARROW_MASK		0x0001
+#define DVDEC_YCSCR12_NARROW_BYPASS		0x0000
+#define DVDEC_YCSCR12_NARROW_17TAP		0x0001
+
+#define DVDEC_ADCCR2_ADC_VINSEL_MASK		0x0001
+
+/* Power supply ON/OFF(ADCCR3 register) */
+#define DVDEC_PSAV_ON		0x0200
+#define DVDEC_PSAV_OFF		0x0210
+
+/* R-Car E2X HW Users Manual rev0.5E */
+/* Table 24D.42 Recommended Setting Common to Various Color Formats */
+#define DVDEC_ADCCR1_INIT		(1 << 8)	/* AGCMODE        */
+
+#define DVDEC_SYNSCR1_INIT		((3 << 13)	/* LPFVSYNC       */\
+					| (5 << 10)	/* LPFHSYNC       */\
+					| (2 << 4)	/* VELOCITYSHIFT_H */\
+					| (2 << 2)	/* SLICERMODE_H   */\
+					| (2 << 0))	/* SLICERMODE_V   */
+
+#define DVDEC_SYNSCR2_INIT		((15 << 6)	/* SYNCMAXDUTY_H  */\
+					| (10 << 0))	/* SYNCMINDUTY_H  */
+
+#define DVDEC_SYNSCR3_INIT		((15 << 10)	/* SSCLIPSEL      */\
+					| (146 << 0))	/* CSYNCSLICE_H   */
+
+#define DVDEC_SYNSCR4_INIT		((15 << 6)	/* SYNCMAXDUTY_V  */\
+					| (9 << 0))	/* SYNCMINDUTY_V  */
+
+#define DVDEC_SYNSCR5_INIT		((0 << 15)	/* VSYNCDELAY     */\
+					| (10 << 10)	/* VSYNCSLICE     */\
+					| (146 << 0))	/* CSYNCSLICE_V   */
+
+#define DVDEC_HAFCCR1_INIT		((12 << 12)	/* HAFCGAIN       */\
+					| (0 << 10)	/* HAFCFREERUN    */\
+					| (692 << 0))	/* HAFCTYP        */
+
+#define DVDEC_HAFCCR2_INIT		((0 << 12)	/* HAFCSTART      */\
+					| (1 << 11)	/* NOX2HOSC       */\
+					| (0 << 10)	/* DOX2HOSC       */\
+					| (742 << 0))	/* HAFCMAX	  */
+
+#define DVDEC_HAFCCR3_INIT		((8 << 12)	/* HAFCEND        */\
+					| (2 << 10)	/* HAFCMODE       */\
+					| (642 << 0))	/* HAFCMIN        */
+
+#define DVDEC_VCDWCR1_INIT		(0 << 15)	/* VCDFREERUN     */
+
+#define DVDEC_VCDWCR1_AUTO		((0 << 15)	/* VCDFREERUN     */\
+					| (0 << 14)	/* NOVCD50	  */\
+					| (0 << 13)	/* NOVCD60	  */\
+					| (0 << 12))	/* VCDDEFAULT	  */
+
+#define DVDEC_VCDWCR1_IMASK		(0x8000)
+
+#define DVDEC_VCDWCR1_AMASK		(0xF800)
+
+#define DVDEC_DCPCR1_INIT		((1 << 15)	/* DCPMODE_Y      */\
+					| (0 << 11)	/* DCPCHECK       */\
+					| (984 << 0))	/* BLANKLEVEL_Y   */
+
+#define DVDEC_DCPCR2_INIT		((0 << 15)	/* DCPMODE_C      */\
+					| (0 << 6)	/* BLANKLEVEL_CB  */\
+					| (0 << 0))	/* BLANKLEVEL_CR  */
+
+#define DVDEC_DCPCR3_INIT		(0 << 12)	/* DCPRESPONSE    */
+
+#define DVDEC_DCPCR4_INIT		(16 << 10)	/* DCPSTART       */
+
+#define DVDEC_DCPCR5_INIT		(16 << 10)	/* DCPEND         */
+
+#define DVDEC_DCPCR6_INIT		(27 << 8)	/* DCPWIDTH       */
+
+#define DVDEC_DCPCR7_INIT		(162 << 8)	/* DCPPOS_Y       */
+
+#define DVDEC_DCPCR8_INIT		(54 << 8)	/* DCPPOS_C       */
+
+#define DVDEC_NSDCR_INIT		((0 << 12)	/* ACFINPUT       */\
+					| (0 << 4)	/* ACFLAGTIME     */\
+					| (3 << 0))	/* ACFFILTER      */
+
+#define DVDEC_BTLCR_INIT		((1 << 14)	/* LOCKRANGE      */\
+					| (3 << 12)	/* LOOPGAIN       */\
+					| (1 << 10)	/* LOCKLIMIT      */\
+					| (0 << 9))	/* BCOFREERUN     */
+
+#define DVDEC_BTGPCR_INIT		((0 << 15)	/* BGPCHECK       */\
+					| (54 << 8)	/* BGPWIDTH       */\
+					| (110 << 0))	/* BGPSTART       */
+
+#define DVDEC_ACCCR1_INIT		((5 << 12)	/* KILLEROFFSET   */\
+					| (0 << 11)	/* ACCMODE        */\
+					| (0 << 9)	/* ACCMAXGAIN     */\
+					| (292 << 0))	/* ACCLEVEL       */
+
+#define DVDEC_ACCCR2_INIT		((0 << 9)	/* CHROMASUBGAIN  */\
+					| (210 << 0))	/* CHROMAMAINGAIN */
+
+#define DVDEC_ACCCR3_INIT		((1 << 14)	/* ACCRESPONSE    */\
+					| (8 << 8)	/* ACCPRECIS      */\
+					| (0 << 7)	/* KILLERMODE     */\
+					| (4 << 1))	/* KILLERLEVEL    */
+
+#define DVDEC_TINTCR_INIT		((0 << 10)	/* TINTSUB        */\
+					| (0 << 0))	/* TINTMAIN       */
+
+#define DVDEC_YCDCR_INIT		((0 << 4)	/* LUMADELAY      */\
+					| (0 << 2)	/* CHROMALPF      */\
+					| (2 << 0))	/* DEMODMODE      */
+
+#define DVDEC_AGCCR1_INIT		((0 << 13)	/* DUREDUCE       */\
+					| (0 << 12)	/* NOREDUCE       */\
+					| (4 << 9)	/* AGCRESPONSE    */\
+					| (236 << 0))	/* AGCLEVEL       */
+
+#define DVDEC_AGCCR2_INIT		(10 << 8)	/* AGCPRECIS      */
+#define DVDEC_AGCCR2_IMASK		(0x3F00)
+
+#define DVDEC_PKLIMITCR_INIT		((2 << 14)	/* PEAKLEVEL      */\
+					| (2 << 12)	/* PEAKATTACK     */\
+					| (3 << 10)	/* PEAKRELEASE    */\
+					| (0 << 8)	/* PEAKRATIO      */\
+					| (20 << 0))	/* MAXPEAKSAMPLES */
+
+#define DVDEC_RGORCR1_INIT		(928 << 0)	/* RADJ_O_LEVEL0  */
+
+#define DVDEC_RGORCR2_INIT		(32 << 0)	/* RADJ_U_LEVEL0  */
+
+#define DVDEC_RGORCR3_INIT		(960 << 0)	/* RADJ_O_LEVEL1  */
+
+#define DVDEC_RGORCR4_INIT		(48 << 0)	/* RADJ_U_LEVEL1  */
+
+#define DVDEC_RGORCR5_INIT		(992 << 0)	/* RADJ_O_LEVEL2  */
+
+#define DVDEC_RGORCR6_INIT		(64 << 0)	/* RADJ_U_LEVEL2  */
+
+#define DVDEC_RGORCR7_INIT		((0 << 12)	/* TEST_MONI      */\
+					| (0 << 9)	/* RADJ_MIX_K_FIX */\
+					| (1 << 2)	/* UCMP_SW        */\
+					| (1 << 1)	/* DCMP_SW        */\
+					| (1 << 0))	/* HWIDE_SW       */
+
+#define DVDEC_AFCPFCR_INIT		((0 << 4)	/* PHDET_FIX      */\
+					| (5 << 0))	/* PHDET_DIV      */
+
+#define DVDEC_RUPDCR_INIT		(1 << 15)	/* NEWSETTING     */
+
+#define DVDEC_YCSCR8_INIT		((0 << 15)	/* HBPF_NARROW    */\
+					| (0 << 14)	/* HVBPF_NARROW   */\
+					| (0 << 13)	/* HBPF1_9TAP_ON  */\
+					| (0 << 12)	/* HVBPF1_9TAP_ON */\
+					| (0 << 11))	/* HFIL_TAP_SEL   */
+
+#define DVDEC_YCSCR11_INIT		((108 << 9)	/* Reserved       */\
+					| (0 << 0))	/* V_Y_LEVEL      */
+
+#define DVDEC_DCPCR9_INIT		((7 << 13)	/* Reserved       */\
+					| (0 << 12)	/* CLP_HOLD_ON_Y  */\
+					| (0 << 11)	/* CLP_HOLD_ON_CB */\
+					| (0 << 10))	/* CLP_HOLD_ON_CR */
+
+#define DVDEC_YGAINCR_INIT		(816 << 0)	/* Y_GAIN2        */
+#define DVDEC_CBGAINCR_INIT		(663 << 0)	/* CB_GAIN2       */
+#define DVDEC_CRGAINCR_INIT		(663 << 0)	/* CR_GAIN2       */
+
+#define DVDEC_PGA_UPDATE_INIT		(1 << 0)	/* PGA_VEN        */
+#define DVDEC_PGACR_INIT		((0 << 14)	/* PGA_GAIN_SEL   */\
+					| (0 << 8)	/* PGA_GAIN       */\
+					| (8 << 0))	/* Reserved       */
+
+#define DVDEC_ADCCR2_INIT		(0 << 0)	/* ADC_VINSEL     */
+
+#endif /* _RCAR_DVDEC_H_ */
\ No newline at end of file
-- 
2.7.4

